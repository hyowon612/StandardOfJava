# 1. 객체지향언어

## 1.1 객체지향 언어의 역사

> **객체지향이론** - 실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용

## 1.2 객체지향언어

기존의 프로그래밍 언어에 몇 가지 새로운 규칙을 추가해 발전 -> 코드 간에 서로 관계를 맺어줌

### 객체지향언어의 주요특징

- 코드의 재사용성이 높음

- 코드의 관리가 용이
- 신뢰성이 높은 프로그래밍 가능

# 2. 클래스와 객체

## 2.1 클래스와 객체의 정의와 용도

|      | 클래스                 | 객체                    |
| ---- | ---------------------- | ----------------------- |
| 정의 | 객체를 정의해 놓은 것  | 실제로 존재하는 것      |
| 용도 | 객체를 생성하는데 사용 | 기능과 속성에 따라 다름 |

클래스 == 제품 설계도

객체 == 제품

클래스 작성후, 클래스로부터 객체를 생성하여 사용

## 2.2 객체와 인스턴스

**클래스의 인스턴스화** - 클래스로부터 객체를 만드는 과정

**클래스의 인스턴스** - 클래스로부터 만들어진 객체

`인스턴스` -> 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미

**클래스** ---`인스턴스화`---> **인스턴스(객체)**

## 2.3 객체의 구성요소 - 속성과 기능

객체는 다수의 **속성(property, 멤버변수)** 과 **기능(function, 메서드)** 을 가지고 있다.

클래스에는 객체의 모든 속성과 기능이 정의되어있다.

각 변수의 자료형은 속성의 값에 알맞은 것을 선택해야 함

```java
class TV {
  // 변수
  String color;
  boolean power;
  int channel;
  
  // 메서드
  void power()	{ power = !power; }
  void channelUp()	{ channel++; }
  void channelDown()	{ channel--; }
}
```

## 2.4 인스턴스의 생성과 사용

### 인스턴스의 생성

```java
클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장
```

1. `클래스명 변수명;` 

   클래스 타입의 참조변수를 선언한다. 메모리에 참조변수를 위한 공간이 마련된다.

2. `변수명 = new 클래스명();`

   연산자 `new`에 의해 클래스의 인스턴스가 메모리의 빈 공간에 생성된다. 멤버변수는 각 **자료형에 해당하는 기본값으로 초기화** 된다. 

   그 다음 대입연산자에 의해서 생성된 객체의 주소값이 참조변수에 저장된다. 이제 참조변수를 통해 인스턴스에 접근할 수 있고 인스턴스를 다루기 위해서는 참조변수가 반드시 필요하다.



> **인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.** 



```java
클래스명 변수1 = new 클래스명();
클래스명 변수2 = new 클래스명();
변수2 = 변수1;
```

1. `변수2 = 변수1;`

   변수1은 참조변수이므로, 인스턴스의 주소를 저장하고 있다. 이 문장을 수행 시 변수2가 가지고 있던 값은 잃어버리고 변수1에 저장되어 있던 값이 변수2에 저장된다. 

   변수2는 변수1이 참조하고 있던 인스턴스를 같이 참조하고, 변수2가 원래 참조하고 있던 인스턴스는 더 이상 사용할 수 없다. 

참조변수에는 하나의 값만 저장될 수 있으므로 둘 이상의 참조변수가 하나의 인스턴스를 참조하는 것은 가능하지만 하나의 참조변수로 여러개의 인스턴스를 참조하는 것은 불가능하다.

## 2.5 객체 배열

참조변수들을 하나로 묶은 참조배열

```java
Tv[] tvArr = new Tv[3]; // 길이가 3인 Tv타입의 참조변수 배열
```

`tvArr`의 각 요소는 참조변수의 기본값인 null로 자동 초기화됨

```java
Tv[] tvArr = new Tv[3]; // 참조변수 배열(객체 배열)을 생성

// 객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();

// 배열의 초기화 블럭을 사용
Tv[] tvArr = { new Tv(), new Tv(), new Tv() };

// for문 사용
Tv[] tvArr = new Tv[100];

for (int i-0;i<tvArr.length;i++) {
  tvArr[i] = new Tv();
}
```

## 2.6 클래스의 또 다른 정의

### 1. 클래스 - 데이터와 함수의 결합

데이터 처리를 위한 데이터 저장형태의 발전과정

변수 --> 배열 --> 구조체 --> 클래스

1. **변수** - 하나의 데이터를 저장할 수 있는 공간
2. **배열** - 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. **구조체** - 서로 관련된 여러 데이털르 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
4. **클래스** - 데이터와 함수의 결합(구조체 + 함수)

변수와 함수를 하나의 클래스에 정의해 서로 관계가 갚은 변수와 함수들을 함께 다룰 수 있게 함.

```java
public final class String implements java.io.Serializable, Comparable {
  private char[] value; // 문자열을 저장하기 위한 공간
  
  public String replace (char, oldChar, char newChar) {
    char[] val = value; // 같은 클래스 내의 변수를 사용해서 작업을 한다.
  }
}
```

String 클래스의 실제 소스 

-> 클래스 내부에 value라는 문자형 배열이 선언되어있음, 문제열을 다루는 데 필요한 함수들 함께 정의

-> 변수와 함수가 서로 유기적으로 연결되어 있어 작업 편리

### 2. 클래스 - 사용자정의 타입(user-defined type)

**사용자정의 타입(user-defined type)** - 프로그래밍언어에서 제공하는 자료형(primitive type)외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것

```java
class Time {
  int hour;
  int minute;
  float second;
}
```

시, 분, 초를 저장하기 위한 세 변수를 멤버변수로 갖는 Time클래스를 정의

```java
// 비객체지향적 코드
int hour1, hour2, hour3;
int minute1, minute2, minute3;
float second1, second2, second3;

// 객체지향적 코드
Time t1 = new Time();
Time t2 = new Time();
Time t3 = new Time();
```

```java
// 비객체지향적 코드
int[] hour = new int[3];
int[] minute = new int[3];
float[] second = new float[3];

// 객체지향적 코드
Time[] t = new Time[3];
t[0] = new Time();
t[1] = new Time();
t[2] = new Time();
```



**참고 - Time클래스

```java
public class Time {
  private int hour;
  private int minute;
  private float second;
  
  public int getHour()	{ return hour; }
  public int getMinute()	{ return minute; }
  public float getSecond() 	{ return second; }
  
  public void setHour(int h) {
    if (h < 0 || h > 23) return;
    hour = h;
  }
  
    public void setMinute(int m) {
    if (m < 0 || m > 59) return;
    minute = m;
  }
  
    public void setSecond(float s) {
    if (s < 0.0f || s > 59.99f) return;
    second = s;
  }
}
```

# 3. 변수와 메서드

## 3.1 선언위치에 따른 변수의 종류

```java
class Variables {
  int iv;		// 인스턴스변수
  static int cv;		// 클래스변수(static변수, 공유변수)
  
  void method() {
    int lv = 0;		// 지역변수
  }
}
```

| 변수의 종류                     | 선언위치                | 생성시기                    |
| ------------------------------- | ----------------------- | --------------------------- |
| 클래스변수(class variable)      | 클래스 영역             | 클래스가 메모리에 올라갈 때 |
| 인스턴스변수(instance variable) | 클래스 영역             | 인스턴스가 생성되었을 때    |
| 지역변수(local variable)        | 클래스 영역 이외의 영역 | 변수 선언문이 수행되었을 때 |

1. 인스턴스변수(instance variable)

   - 클래스의 인스턴스를 생성할 때 만들어짐

   - 인스턴스마다 서로 다른 값 가질 수 있음

2. 클래스변수(class variable)

   - 모든 인스턴스가 공통된 저장공간을 공유
   - 인스턴스 생성 없이 사용 가능 -> `클래스이름.클래스변수`
   - 클래스가 메모리에 로딩될 때 생성, 프로그램이 종료될 때 까지 유지
   - `public` 을 앞에 붙이면 전역변수

3. 지역변수(local variable)

   - 메서드 내에서만 사용 가능
   - 메서드가 종료되면 소멸
   - 지역변수가 선언된 블럭{} 내에서만 사용 가능

## 3.2 클래스변수와 인스턴스변수

> 인스턴스변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로, 항상 공통된 값을 갖는다. 

## 3.3 메서드

특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것

### 메서드를 사용하는 이유

1. 높은 재사용성
   - 한번 메소드를 만들어 놓으면 여러 번 호출 가능

2. 중복된 코드의 제거
   - 반복되는 문장들을 하나의 메서드로 작성 시, 메소드를 호출하는 한 문장으로 대체 가능

3. 프로그램의 구조화
   - 문장을 작업단위로 나눠서 여럭 개의 메서드에 담아 프로그램의 구조를 단순화 

## 3.4 메서드의 선언과 구현

```java
// 선언부
반환타입 메서드이름 (타입 변수명, 타입 변수명, ... )
// 구현부
{
  // 메서드 호출 시 수행될 코드
}

// 예시
int add(int a, int b) {
  int result a + b;
  return result; 	// 호출한 메서드로 결과를 반환한다. 
}
```

### 메서드 선언부

- 메서드의 이름
  - 변수의 명명규칙대로 작성
  - 동사인 경우가 많다, 기능을 알 수 있는 함축적이고 의미있는 이름
- 매개변수 선언
  - 작업 수행 시 필요한 값들을 제공받기 위한 것
  - 타입 생략 불가능
  - 입력이 필요 없으면 괄호() 안에 아무 것도 적지 않음
- 반환타입
  - 반환값의 타입을 적는다.
  - 반환값이 없을 경우 `void` 를 적음

### 메서드 구현부

-  return문
  - 반환타입이 `void` 가 아닌 경우, `return 반환값;`  반드시 포함
  - 반환값은 타입은 **반환타입과 일치하거나 적어도 자동 형변환이 가능한 것** 이어야함
  - 반환값은 최대 하나

- 지역변수
  - 서로 다른 메서드 내에 선언된 변수들은 이름이 같아도 된다. 

## 3.5 메서드의 호출

**인자(argument)와 매개변수(parameter)**

- 인자의 개수와 순서는 호출된 메서드에 선언된 매개변수와 일치해야 함
- 타입 일치, 자동 형변환 가능해야 함

### 메서드의 실행흐름

- ~~static메서드는 같은 클래스 내의 인스턴드 메서드를 호출할 수 없음~~ ??

```java
MyMath mm = new MyMath();		// 인스턴스를 생성한다.
long value = mm.add(1L, 2L);		// 메서드를 호출한다.
```

- 호출한 자리를 반환값이 대신하고 대입연산자에 의해 이 값이 변수 `value` 에 저장
- long 또는 long으로 자동 형변환이 가능한 값을 지정해야 함

## 3.6 return문

- 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아감
- 반환타입 void인 경우, 컴파일러가 메서드의 마지막에 `return;` 을 자동적으로 추가

### 매개변수의 유효성 검사

```java
float divide(int x, int y) {
  // 작업을 하기 전에 나누는 수(y)가 0 인지 확인한다.
	if(y == 0) {
    System.out.println("0으로 나눌 수 없습니다.");
    return 0;		// 매개변수가 유효하지 않으므로 메서드를 종료한다.
  }
  return x / (float)y;
}
```
