# 1. 객체지향언어

## 1.1 객체지향 언어의 역사

> **객체지향이론** - 실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용

## 1.2 객체지향언어

기존의 프로그래밍 언어에 몇 가지 새로운 규칙을 추가해 발전 -> 코드 간에 서로 관계를 맺어줌

### 객체지향언어의 주요특징

- 코드의 재사용성이 높음

- 코드의 관리가 용이
- 신뢰성이 높은 프로그래밍 가능

# 2. 클래스와 객체

## 2.1 클래스와 객체의 정의와 용도

|      | 클래스                 | 객체                    |
| ---- | ---------------------- | ----------------------- |
| 정의 | 객체를 정의해 놓은 것  | 실제로 존재하는 것      |
| 용도 | 객체를 생성하는데 사용 | 기능과 속성에 따라 다름 |

클래스 == 제품 설계도

객체 == 제품

클래스 작성후, 클래스로부터 객체를 생성하여 사용

## 2.2 객체와 인스턴스

**클래스의 인스턴스화** - 클래스로부터 객체를 만드는 과정

**클래스의 인스턴스** - 클래스로부터 만들어진 객체

`인스턴스` -> 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미

**클래스** ---`인스턴스화`---> **인스턴스(객체)**

## 2.3 객체의 구성요소 - 속성과 기능

객체는 다수의 **속성(property, 멤버변수)** 과 **기능(function, 메서드)** 을 가지고 있다.

클래스에는 객체의 모든 속성과 기능이 정의되어있다.

각 변수의 자료형은 속성의 값에 알맞은 것을 선택해야 함

```java
class TV {
  // 변수
  String color;
  boolean power;
  int channel;
  
  // 메서드
  void power()	{ power = !power; }
  void channelUp()	{ channel++; }
  void channelDown()	{ channel--; }
}
```

## 2.4 인스턴스의 생성과 사용

### 인스턴스의 생성

```java
클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장
```

1. `클래스명 변수명;` 

   클래스 타입의 참조변수를 선언한다. 메모리에 참조변수를 위한 공간이 마련된다.

2. `변수명 = new 클래스명();`

   연산자 `new`에 의해 클래스의 인스턴스가 메모리의 빈 공간에 생성된다. 멤버변수는 각 **자료형에 해당하는 기본값으로 초기화** 된다. 

   그 다음 대입연산자에 의해서 생성된 객체의 주소값이 참조변수에 저장된다. 이제 참조변수를 통해 인스턴스에 접근할 수 있고 인스턴스를 다루기 위해서는 참조변수가 반드시 필요하다.



> **인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.** 



```java
클래스명 변수1 = new 클래스명();
클래스명 변수2 = new 클래스명();
변수2 = 변수1;
```

1. `변수2 = 변수1;`

   변수1은 참조변수이므로, 인스턴스의 주소를 저장하고 있다. 이 문장을 수행 시 변수2가 가지고 있던 값은 잃어버리고 변수1에 저장되어 있던 값이 변수2에 저장된다. 

   변수2는 변수1이 참조하고 있던 인스턴스를 같이 참조하고, 변수2가 원래 참조하고 있던 인스턴스는 더 이상 사용할 수 없다. 

참조변수에는 하나의 값만 저장될 수 있으므로 둘 이상의 참조변수가 하나의 인스턴스를 참조하는 것은 가능하지만 하나의 참조변수로 여러개의 인스턴스를 참조하는 것은 불가능하다.

## 2.5 객체 배열

참조변수들을 하나로 묶은 참조배열

```java
Tv[] tvArr = new Tv[3]; // 길이가 3인 Tv타입의 참조변수 배열
```

`tvArr`의 각 요소는 참조변수의 기본값인 null로 자동 초기화됨

```java
Tv[] tvArr = new Tv[3]; // 참조변수 배열(객체 배열)을 생성

// 객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();

// 배열의 초기화 블럭을 사용
Tv[] tvArr = { new Tv(), new Tv(), new Tv() };

// for문 사용
Tv[] tvArr = new Tv[100];

for (int i-0;i<tvArr.length;i++) {
  tvArr[i] = new Tv();
}
```

## 2.6 클래스의 또 다른 정의

### 1. 클래스 - 데이터와 함수의 결합

데이터 처리를 위한 데이터 저장형태의 발전과정

변수 --> 배열 --> 구조체 --> 클래스

1. **변수** - 하나의 데이터를 저장할 수 있는 공간
2. **배열** - 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. **구조체** - 서로 관련된 여러 데이털르 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
4. **클래스** - 데이터와 함수의 결합(구조체 + 함수)

변수와 함수를 하나의 클래스에 정의해 서로 관계가 갚은 변수와 함수들을 함께 다룰 수 있게 함.

```java
public final class String implements java.io.Serializable, Comparable {
  private char[] value; // 문자열을 저장하기 위한 공간
  
  public String replace (char, oldChar, char newChar) {
    char[] val = value; // 같은 클래스 내의 변수를 사용해서 작업을 한다.
  }
}
```

String 클래스의 실제 소스 

-> 클래스 내부에 value라는 문자형 배열이 선언되어있음, 문제열을 다루는 데 필요한 함수들 함께 정의

-> 변수와 함수가 서로 유기적으로 연결되어 있어 작업 편리

### 2. 클래스 - 사용자정의 타입(user-defined type)

**사용자정의 타입(user-defined type)** - 프로그래밍언어에서 제공하는 자료형(primitive type)외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것

```java
class Time {
  int hour;
  int minute;
  float second;
}
```

시, 분, 초를 저장하기 위한 세 변수를 멤버변수로 갖는 Time클래스를 정의

```java
// 비객체지향적 코드
int hour1, hour2, hour3;
int minute1, minute2, minute3;
float second1, second2, second3;

// 객체지향적 코드
Time t1 = new Time();
Time t2 = new Time();
Time t3 = new Time();
```

```java
// 비객체지향적 코드
int[] hour = new int[3];
int[] minute = new int[3];
float[] second = new float[3];

// 객체지향적 코드
Time[] t = new Time[3];
t[0] = new Time();
t[1] = new Time();
t[2] = new Time();
```



**참고 - Time클래스

```java
public class Time {
  private int hour;
  private int minute;
  private float second;
  
  public int getHour()	{ return hour; }
  public int getMinute()	{ return minute; }
  public float getSecond() 	{ return second; }
  
  public void setHour(int h) {
    if (h < 0 || h > 23) return;
    hour = h;
  }
  
    public void setMinute(int m) {
    if (m < 0 || m > 59) return;
    minute = m;
  }
  
    public void setSecond(float s) {
    if (s < 0.0f || s > 59.99f) return;
    second = s;
  }
}
```

