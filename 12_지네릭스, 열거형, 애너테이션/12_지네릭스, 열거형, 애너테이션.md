# 1. 지네릭스(Generics)

## 1.1 지네릭스란?

다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 **타입체크**를 해주는 기능

**지네릭스의 장점**

1. 타입 안정성을 제공
2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해짐

-> 다룰 객체의 타입을 미리 명시해줌

## 1.2 지네릭 클래스의 선언

클래스/메서드 에 선언 가능

```java
class Box {
  Object item;
  
  void setItem(Object item) { this.item = item; }
  Object getItem() { return item; }
}

// 지네릭 클래스로 변경
class Box<T> {	// 지네릭 타입 T를 선언
  T item;
  
  void setItem(T item) { this.item = item; }
  T getItem() { return item; }
}
```

- `Box<T>` 에서 **T**는 타입 변수, Type의 첫 글자
- 타입 변수가 여러 개인 경우 `Map<K,V>` 와 같이 콤마로 구분
- **기호의 종류만 다를 뿐 '임의의 참조형 타입'을 의미하는 것은 같음**



지네릭 클래스의 객체를 생성할 때는 참조변수와 생성자에 실제타입 지정

```java
Box<String> b = new Box<String>();	// 타입 T 태신, 실제 타입을 지정
b.setItem(new Object());	// 에러. String이외의 타입은 지정불가
b.setItem("ABC");	// OK. String타입이므로 가능
String item = b.getItem();	// 형변환이 필요없음
```



지네릭이 도입되기 이전의 코드와 호환을 위해, 지네릭 클래스인데도 예전의 방식으로 객체를 생성하는 것 허용

```java
Box b = new Box();	// OK. T는 Object로 간주된다.
b.setItem("ABC");	// 경고. unchecked or unsafe operation
b.setItem(new Object());	// 경고. unchecked or unsafe operation
```



### 지네릭스의 용어

```java
class Box<T> {}

Box<T> // 지네릭 클래스. 'T의 Box' 또는 'T Box'라고 읽음.
T // 타입 변수 또는 타입 매개변수.(T는 타입 문자)
Box // 원시 타입
```



### 지네릭스의 제한

모든 객체에 대해 동일하게 동작해야하는 static멤버에 타입 변수 T를 사용할 수 없음.

T는 인스턴스변수로 간주되기 때문.

```java
class Box<T> {
  static T item;	// 에러
  static int compare(T t1, T t2) { ... }	// 에러
}
// static 멤버는 타입변수에 지정된 타입, 즉 대입된 타입의 종류에 관계없이 동일한 것이어야하기 때문

class Box<T> {
  T[] itemArr;	// OK. T타입의 배열을 위한 참조변수
  
  T[] toArray() {
    T[] tmpArr = new T[itemArr.length];	// 에러. 지네릭 배열 생성불가
    
    return tmpArr;
  }
}
```



## 1.3 지네릭 클래스의 객체 생성과 사용

```java
class Box<T> {
  ArrayList<T> list = new ArrayList<T>();
  
  void add(T item)	{ list.add(item); }
  T get(int i)	{ return list.get(i); }
  ArrayList<T> getList() { return list; }
  int size() { return list.size(); }
  public String toString() { return list.toString(); }
}
```

```java
// 참조변수와 생성자에 대입된 타입이 일치해야 함
Box<Apple> appleBox = new Box<Grape();	// 에러

// 두 타입에 상속관계에 있어도 X
Box<Fruit> appleBox = new Box<Apple>();	// 에러. 대입된 타입이 다르다.

// 두 지네릭 클래스의 타입이 상속관계에 있고, 대입된 타입이 같으면 가능
Box<Apple> appleBox = new FruitBox<Apple>();	// OK. 다형성
```



## 1.4 제한된 지네릭 클래스

지네릭 타입에 'extends'를 사용하면, 특정 타입의 자손들만 대입할 수 있게 제한 가능

```java
class FruitBox<T extends Fruit> {	// Fruit의 자손만 타입으로 지정가능
	ArrayList<T> list = new ArrayList<T>();
}
```



## 1.5 와일드 카드

**지네릭 타입이 다른 것만으로는 오버로딩 성립X**

```java
<? extends T>	// 와일드 카드의 상한 제한. T와 그 자손들만 가능
<? super T>	// 와일드 카드의 하한 제한. T와 그 조상들만 가능
<?>	// 제한 없음. 모든 타입이 가능. <? extends Object>와 동일
```



## 1.6 지네릭 메서드

메서드의 선언부에 지네릭 타입이 선언된 메서드

```java
static <T> void sort(List<T> list, Comparator<? super T> c)
```

- static 옆에 있는 `<T>` 는 메서드에 선언된 지네릭 타입
- 첫번째 매개변수는 정렬할 대상
- 두번째 매개변수는 정렬할 방법이 정의된 Comparator



```java
static Juice makeJuice(FruitBox<? extends Fruit> box) {
  String tmp = "";
  for(Fruit f : box.getList()) tmp += f + " ";
  return new Juice(tmp);
}

// 지네릭 메서드
static <T extends Fruit> Juice makeJuice(FruitBox<T> box) {
  String tmp = "";
  for(Fruit f : box.getList()) tmp += f + " ";
  return new Juice(tmp);
}
```

```java
// 메서드를 호출할 시 타입 변수에 타입 대입
FruitBox<Apple> appleBox = new FruitBox<Apple>();
System.out.println(Juice.<Fruit>makeJuice(fruitBox));

// 대부분의 경우 컴파일러가 타입을 추정할 수 있기 때문에 생략 가능
System.out.println(Juicer.makeJuice(fruitBox));	// 대입된 타입을 생략할 수 있다.
```

