# 1. 컬렉션 프레임웍(Collection Framework)

**데이터 군을 저장하는 클래스들을 표준화한 설계**

컬렉션 - 데이터 그룹

프레임웍 - 표준화된 프로그래밍 방식

## 1.1 컬렉션 프레임웍의 핵심 인터페이스

컬렉션데이터 그룹을 크게 3가지 타입이 존재한다고 인식

List, Set의 공통된 부분을 다시 뽑아서 새로운 인터페이스인 Collection을 추가로 정의

| 인터페이스 | 특징                                                         |
| ---------- | ------------------------------------------------------------ |
| **List**   | 순서가 있는 데이터의 집함. 데이터의 중복을 허용한다.<br />예) 대기자 명단<br />구현클래스 : ArrayList, LinkedList, Stack, Vector 등 |
| **Set**    | 순서를 유지하지 않는 데이터의 집함. 데이터의 중복을 허용하지 않는다.<br />예) 양의 정수집합, 소수의 집합<br />구현클래스 : HashSet, TreeSet 등 |
| **Map**    | 키와 값의 쌍으로 이루어진 데이터의 집합<br />순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값을 중복을 허용한다.<br />예) 우편번호, 지역번호(전화번호)<br />구현클래스 : HastMap, TreeMap, Hashtable, Properties 등 |

### Collection인터페이스

컬렉션 클래스에 저장된 데이터를 읽고, 추가하고 삭제하는 등 컬렉션을 다루는 데 가장 기본적인 메서드들을 정의

### List인터페이스

중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는 데 사용된다.

### Set인터페이스

중복을 허용하지 않고 저장순서가 유지되지 않는 컬렉션 클래스를 구현하는 데 사용

### Map인터페이스

키와 값을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는 데 사요

### Map.Entry인터페이스

Map인터페이스의 내부 인터페이스

Map에 저장되는 key-value쌍을 다루기 위해 내부적으로 Entry인터페이스 정의

## 1.2 ArrayList

- List인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고 중복을 허용

- Object배열을 이용해서 데이터를 순차적으로 저장

```java
public class ArrayList extends AbstractList
  implements List, RandomAccess, Cloneable, java.io.Serializable {
  	...
    transient Object[] elementData;	// Object배열
}
```

- elementData라는 이름의 Object배열을 멤버변수로 선언
- 모든 종류의 객체를 담을 수 있음



- ArrayList를 생성할 때, 저장할 요소의 개수를 고려해서 실제 저장할 개수보다 약간 여유있는 크기로 하는 것이 좋음
  - 지정한 크기보다 더 많은 객체를 저장할 시 자동적으로 크기가 늘어날 때 처리시간이 많이 소요



- 배열을 이용한 자료구조(ArrayList)는 데이터를 읽어오고 저장하는 데는 효율이 좋지만, 용량을 변경해야할 때는 새로운 배열을 생성한 후 기존의 배열로부터 새로 생성된 배열로 데이털르 복사해야하기 때문에 효율이 떨어짐

## 1.3 LinkedList

> **배열의 장점**
>
> - 구조가 간단
> - 사용하기 쉬움
> - 접근시간 빠름
>
> **배열의 단점**
>
> - 크기를 변경할 수 없음
>   - 크기를 변경할 수 없으므로 새로운 배열을 생성해서 데이터를 복사해야함
>   - 실행속도를 향상시키기 위해서는 충분히 큰 크기의 배열을 생성해야 하므로 메모리가 낭비
> - 비순차적인 데이터의 추가/삭제에 시간 많이 걸림
>   - 차례대로 데이털르 추가하고 마지막에서부터 데이터를 삭제하는 것을 빠름
>   - 배열의 중간에 데이터를 추가하려면, 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야 함

위의 배열의 단점을 보완한 것이 LinkedList

- 불연속적으로 전재하는 데이터를 서로 연결한 형태로 구성



- 링크드 리스트의 각 요소(node)들을 자신과 연결된 다음 요소에 대한 주소값과 데이터로 구성

- 단방향이기 때문에 이전요소에 대한 접근이 어려워 보완한 것이 더블 링크드 리스트
  - 이전 요소에 대한 참조가 가능

```java
// 링크드 리스트
class Node {
  Node next;	// 다음 요소의 주소를 저장
  Object obj;	// 데이터를 저장
}

// 더블 링크드 리스트
class Node {
  Node next;	// 다음 요소의 주소를 저장
  Node previous;	// 이전 요소의 주소를 저장
  Object obj;	// 데이터를 저장
}
```

더블 링크드 리스트의 접근성을 향상시킨 것이 더블 써큘러 링크드 리스트

-> 더블 링크드 리스트의 첫 번쨰 요소와 마지막 요소를 서로 연결시킨 것



1. **순차적으로 추가/삭제하는 경우 ArrayList가 LinkedList보다 빠르다.**
2. **중간 데이터를 추가/삭제하는 경우 LinkedList가 ArrayList보다 빠르다.**



배열의 경우 인덱스가 n인 요소의 값을 얻어 오고자 한다면 

**인덱스가 n인 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기**

LinkedList는 처음부터 n번째 데이터까지 차례대로 따라가야함

- LinkedList는 저장해야하는 데이터의 개수가 많아질수록 데이터를 읽어 오는 접근시간이 길어짐

| 컬렉션     | 읽기(접근시간) | 추가/삭제 | 비고                                                    |
| ---------- | -------------- | --------- | ------------------------------------------------------- |
| ArrayList  | 빠르다         | 느리다    | 순차적인 추가삭제는 더 빠름.<br />비효율적이 메모리사용 |
| LinkedList | 느리다         | 빠르다    | 데이터가 많을수록 접근성이 떨어짐                       |

## 1.4 Stack과 Queue

**Stack** - LIFO

- ArrayList와 같은 배열기반의 컬렉션 클래스가 적합

**Queue** - FIFO

- 배열기반의 컬렉션 클래스를 사용할 경우 데이터를 꺼낼때마다 빈공간을 채우기 위해 복사가 발생하므로 ㅂ효율적
  - 데이터 추가/삭제가 쉬운 LinkedList가 적합

### 스택과 큐의 활용

> **스택의 활용 예** - 수식계산, 수식괄호검사, 워드프로세서의 undo/redo, 웹브라우저의 뒤로/앞으로
>
> **큐의 활용 예** - 최근사용문서, 인쇄작업 대기목록, 버퍼

### PriorityQueue

- 저장한 순서에 관계없이 우선순위가 높은 것부터 꺼냄

- null은 저장할 수 없음
- 저장공간으로 배열 사용, 각 요소를 힙의 형태로 저장

### Deque(Double-Ended Queue)

- 양쪽 끝에 추가/삭제 가능

| Deque       | Queue   | Stack  |
| ----------- | ------- | ------ |
| offerLast() | offer() | push() |
| pollLast()  | -       | pop()  |
| pollFirs()  | poll()  | -      |
| peekFirst() | peek()  |        |
| peekLast()  | -       | peek() |

## 1.5 Iterator, ListIterator, Enumeration

컬렉션에 저장된 요소를 접근하는데 사용

### Iterator

```java
public interface Iterator {
  boolean hasNext();
  Object next();
  void remove();
}
public interface Collection {
  public Iterator iterator();
}
```

컬렉션 클래스에 대해 iterator()를 호출하여 Iterator를 얻은 다음 반복문을 사용해서 컬렉션 클래스의 요소들을 읽어옴

